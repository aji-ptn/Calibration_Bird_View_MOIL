import cv2
import numpy as np
from .Moildev import Moildev


def connect_to_moildev(filepath_parameter, type_camera=None):
    """

    Args:
        filepath_parameter:
        type_camera:

    Returns:

    """
    try:
        moildev = Moildev.Moildev(filepath_parameter, type_camera)
    except:
        moildev = None

    return moildev


def check_Port_USB_Camera():
    """
    Detect the USB camera port available and show it on message box prompt.

    Returns:

    """
    all_camera_idx_available = []
    for camera_idx in range(5):
        cap = cv2.VideoCapture(camera_idx)
        if cap.isOpened():
            all_camera_idx_available.append(camera_idx)
            cap.release()

    return all_camera_idx_available


def remap_image(image, mapX, mapY):
    """
    The purpose is to generate a pair of X-Y Maps for the specified zenith angle, azimuthal angle,
    and zoom factor. The result X-Y Maps can be used later to remap the original fish-eye image to
    the target angle image with undistortion result.

    Args:
        image: Input image
        mapX: The mapping function in the x direction.
        mapY: The mapping function in the y direction.

    Returns:
        image: Updating the image after remapping

    - Example:

    .. code-block:: python

        image_anypoint = remap_image(image, mapX_anypoint, mapY_anypoint)
    """
    image = cv2.remap(image, mapX, mapY, cv2.INTER_CUBIC)
    return image


def read_image(image_path):
    """
    Method loads an image from the specified file (use the cv2.imread function to complete the task).
    If the image cannot be read (because of missing file, improper permissions, unsupported or invalid format)
    then this method returns an empty matrix.

    Args:
        image_path : The path of image file

    return:
        Image: load image

    - Example:

    .. code-block:: python

        image = read_image(image_path)
    """
    image = cv2.imread(image_path)
    if image is None:
        raise FileNotFoundError("`{}` cannot be loaded".format(image_path))
    return image


def rotate_image(src, angle, center=None, scale=1.0):
    """
    Rotation of images are among the most basic operations under the broader class of
    Affine transformations. This function will return the image after turning clockwise
    or anticlockwise depending on the angle given.

    Args:
        src: original image
        angle: the value angle for turn the image
        center: determine the specific coordinate to rotate image
        scale: scale image

    Returns:
        dst image: rotated image

    - Example:

    .. code-block:: python

        image = rotate_image(image, 90)
    """
    h, w = src.shape[:2]
    if center is None:
        center = (w / 2, h / 2)
    m = cv2.getRotationMatrix2D(center, angle, scale)
    rotated = cv2.warpAffine(src, m, (w, h))
    return rotated


def resize_image(image, width):
    """
    Changing the dimensions of image according to the size width given (it use cv2.resize function from OpenCV).
    It will keep the aspect ratio of the original image.

    Args:
        image: image original
        width: image width we want

    Returns:
        result: image has been resize

    - Example:

    .. code-block:: python

        image = resize_image(image, 140)
    """
    h, w = image.shape[:2]
    r = width / float(w)
    hi = round(h * r)
    result = cv2.resize(image, (width, hi),
                        interpolation=cv2.INTER_AREA)
    return result


def calculate_height(image, width):
    """
    Return the height value of an image by providing the width value. This high
    value is calculated by keeping the aspect ratio of the image.

    Args:
        image: original image
        width: size image we want

    Returns:
        height: height image

    - Example:

    .. code-block:: python

        height = calculate_height(image, 140)
    """

    h, w = image.shape[:2]
    r = width / float(w)
    height = round(h * r)
    return height


def draw_polygon_fov(image, mapX, mapY):
    """
    Return image with a drawn polygon on it from mapX and mapY generated by maps anypoint or panorama.

    Args:
        image: Original image
        mapX: map image X from anypoint process
        mapY: map image Y from anypoint process

    return:
        image: map x, map y

    - Example:

    .. code-block:: python

        image = draw_polygon(image,mapX,mapY)
    """
    hi, wi = image.shape[:2]
    X1 = []
    Y1 = []
    X2 = []
    Y2 = []
    X3 = []
    Y3 = []
    X4 = []
    Y4 = []

    x = 0
    while x < wi:
        a = mapX[0,]
        b = mapY[0,]
        ee = mapX[-1,]
        f = mapY[-1,]

        if a[x] == 0. or b[x] == 0.:
            pass
        else:
            X1.append(a[x])
            Y1.append(b[x])

        if f[x] == 0. or ee[x] == 0.:
            pass
        else:
            Y3.append(f[x])
            X3.append(ee[x])
        x += 10

    y = 0
    while y < hi:
        c = mapX[:, 0]
        d = mapY[:, 0]
        g = mapX[:, -1]
        h = mapY[:, -1]

        # eliminate the value 0 for map X
        if d[y] == 0. or c[y] == 0.:  # or d[y] and c[y] == 0.0:
            pass
        else:
            Y2.append(d[y])
            X2.append(c[y])

        # eliminate the value 0 for map Y
        if h[y] == 0. or g[y] == 0.:
            pass
        else:
            Y4.append(h[y])
            X4.append(g[y])

        # render every 10 times, it will be like 1, 11, 21 and so on.
        y += 10

    r = np.array([X3, Y3])
    points3 = r.T.reshape((-1, 1, 2))

    # Draw polyline on original image
    cv2.polylines(image, np.int32([points3]), False, (0, 255, 0), 10)
    return image


def draw_polygon(image, mapX, mapY):
    """
    Return image with a drawn polygon on it from mapX and mapY generated by maps anypoint or panorama.

    Args:
        image: Original image
        mapX: map image X from anypoint process
        mapY: map image Y from anypoint process

    return:
        image: map x, map y

    - Example:

    .. code-block:: python

        image = draw_polygon(image,mapX,mapY)
    """
    hi, wi = image.shape[:2]
    X1 = []
    Y1 = []
    X2 = []
    Y2 = []
    X3 = []
    Y3 = []
    X4 = []
    Y4 = []

    x = 0
    while x < wi:
        a = mapX[0,]
        b = mapY[0,]
        ee = mapX[-1,]
        f = mapY[-1,]

        if a[x] == 0. or b[x] == 0.:
            pass
        else:
            X1.append(a[x])
            Y1.append(b[x])

        if f[x] == 0. or ee[x] == 0.:
            pass
        else:
            Y3.append(f[x])
            X3.append(ee[x])
        x += 10

    y = 0
    while y < hi:
        c = mapX[:, 0]
        d = mapY[:, 0]
        g = mapX[:, -1]
        h = mapY[:, -1]

        # eliminate the value 0 for map X
        if d[y] == 0. or c[y] == 0.:  # or d[y] and c[y] == 0.0:
            pass
        else:
            Y2.append(d[y])
            X2.append(c[y])

        # eliminate the value 0 for map Y
        if h[y] == 0. or g[y] == 0.:
            pass
        else:
            Y4.append(h[y])
            X4.append(g[y])

        # render every 10 times, it will be like 1, 11, 21 and so on.
        y += 10

    p = np.array([X1, Y1])
    q = np.array([X2, Y2])
    r = np.array([X3, Y3])
    s = np.array([X4, Y4])
    points = p.T.reshape((-1, 1, 2))
    points2 = q.T.reshape((-1, 1, 2))
    points3 = r.T.reshape((-1, 1, 2))
    points4 = s.T.reshape((-1, 1, 2))

    # Draw polyline on original image
    cv2.polylines(image, np.int32([points]), False, (0, 0, 255), 10)
    cv2.polylines(image, np.int32([points2]), False, (255, 0, 0), 10)
    cv2.polylines(image, np.int32([points3]), False, (0, 255, 0), 10)
    cv2.polylines(image, np.int32([points4]), False, (0, 255, 0), 10)
    return image


def drawPoint(image, coordinatePoint, radius=5):
    """
    Drawing point on the image.

    Args:
        image ():
        coordinatePoint ():
        radius ():

    Returns:

    """

    if coordinatePoint is not None:
        w, h = image.shape[:2]
        if h >= 1000:
            cv2.circle(image, coordinatePoint, radius, (200, 5, 200), 30, -1)
        else:
            cv2.circle(image, coordinatePoint, radius, (200, 5, 200), -1)
    return image
